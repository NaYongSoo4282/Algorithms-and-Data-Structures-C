# 설계결정
1. 데이터는 정수로만 받는다.
    우선 간단한 케이스를 구현해보기 위함. 
2. 데이터 중복은 없다.
    데이터 중복을 다루는 케이스로 변모할 예정
3. 단일연결리스트
    이중연결리스트는 다른 버전으로 구현 예정
# 설계사항
1. 더미 노드 사용
    더미 노드를 사용하지 않으면 오류가 발생하기 쉬움. (예외처리, 삽입과 삭제의 복잡함)
    더미 노드를 사용해서 발생하는 비용은 sizeof(Node)

# Study
1. [메모리 해제] 
    free(Pointer) -> 힙 메모리의 값을 0이나 삭제하는 것이 아니다. 해당 주소의 메모리를 다른 용도로 사용해도 된다는 허가.
    Pointer = NULL; 처리를 해야한다. 그렇지 않으면 쓰레기 값이(힙 메모리) 오류를 발생시킬 수도 있다. 
2. [더미 노드]
    목적 : 첫 노드 삽입, 마지막 노드 삭제하는 경우와 중간에 삽입/삭제하는 경우의 로직을 동일화
    장점 : 가독성 상승
    단점 : O(1) 만큼 공간 사용 < 하지만 오류 발생 가능성 현저히 하락 -> 비용 감축 > 

# 분석
1. #성능 분석 (Performance Analysis)
    각 메서드 별 구분
2. 용어의 구체화 (Dummy Node vs Sentinel Node)
    #설계사항 수정 제안
    1. Sentinel Node (Dummy Head) 패턴 적용
        Why: 경계 조건(Boundary Condition - 첫 노드 삭제, 빈 리스트 처리 등)을 제거하여 로직의 **일관성(Consistency)**을 확보.
        Trade-off: 노드 1개분의 추가 메모리 할당($O(1)$ Space Overhead)이 발생하지만, 코드 복잡도를 낮춰 유지보수성을 높이는 이득이 더 큼.
3. 단일 연결 리스트를 선택한 '철학적 이유' 보강
    #설계결정 보강
    1. 단일 연결 리스트 (Singly Linked List)이중 연결 리스트(DLL) 대비 노드당 포인터가 1개 적어 메모리 사용량이 적음 (Memory Efficient).역방향 탐색이 불가능하고 Tail 삭제가 비효율적($O(N)$)이라는 단점을 인지하고 있으나, 구현의 간결함과 순방향 데이터 처리에 집중하기 위해 선택.


//Gemini 예제

# Project: Single Linked List Implementation in C

C언어를 사용하여 **단일 연결 리스트(Singly Linked List)**를 밑바닥부터(Scratch) 구현한 프로젝트입니다.
라이브러리에 의존하지 않고 포인터와 메모리 관리의 본질을 이해하는 데 집중했습니다.

---

## 1. 설계 결정 및 철학 (Design Decisions)

단순한 구현을 넘어, 각 기능이 **왜** 필요한지 고민하며 설계를 진행했습니다.

### ① 데이터 명세
* **Type:** `int` (정수)
    * 복잡한 데이터 구조보다는 리스트의 동작 로직 자체에 집중하기 위해 기본 타입을 선택했습니다.
* **Constraints:** 중복 데이터 허용 안 함 (Unique Key)
    * 추후 해시 충돌(Hash Collision) 처리 등을 염두에 두고, 현재는 고유성 보장에 초점을 맞췄습니다.

### ② 자료구조 선택: Single vs Double
* **선택:** **단일 연결 리스트 (Singly Linked List)**
* **Reasoning:**
    * **Memory Efficiency:** 이중 연결 리스트(DLL)와 달리 노드당 포인터가 1개(`Next`)만 필요하므로 메모리 오버헤드가 적습니다.
    * **Trade-off:** `Tail` 삭제나 역방향 탐색 시 $O(N)$의 비용이 발생한다는 단점을 인지하고 있으나, **구현의 간결함**과 **순방향 데이터 처리 흐름**을 명확히 익히기 위해 이 구조를 채택했습니다.

---

## 2. 핵심 구현 패턴: Sentinel Node

이번 프로젝트에서 가장 공들인 부분은 **Sentinel Node (Dummy Head)** 패턴의 적용입니다.

### 🚨 문제 상황 (Problem)
초기 구현 시, **'첫 번째 노드'**를 삭제/삽입할 때와 **'중간 노드'**를 처리할 때의 로직이 달라 분기문(`if-else`)이 다수 발생했습니다. 이는 코드의 가독성을 해치고 버그 발생 가능성을 높였습니다.

### 💡 해결책 (Solution)
데이터를 담지 않는 가짜 노드(**Sentinel Node**)를 리스트의 맨 앞에 항상 두었습니다.

* **일관성(Consistency):** 모든 노드가 "이전 노드"를 가지게 되어, 삭제 로직이 단 하나로 통일되었습니다.
* **비용:** $O(1)$ (노드 1개분의 추가 메모리 공간)
* **이득:** 경계 조건(Boundary Condition) 제거를 통한 코드 안정성 확보.

---

## 3. 성능 분석 (Performance Analysis)

현재 구현된 단일 연결 리스트의 시간 복잡도는 다음과 같습니다. (N: 노드 개수)

| Operation | Time Complexity | Description |
| :--- | :---: | :--- |
| **Search (Get)** | $O(N)$ | 인덱싱이 불가능하므로 Head부터 순차 탐색 |
| **Insert (Append)** | $O(N)$ | Tail 포인터를 두지 않았으므로 끝까지 순회 필요 |
| **Delete** | $O(N)$ | 삭제할 대상을 찾기 위해 순차 탐색 필요 |

> **Self-Feedback:** 대량의 데이터 입력이 필요한 경우, `Tail` 포인터를 추가하여 Insert를 $O(1)$로 최적화하거나 이중 연결 리스트 도입을 고려해야 함.

---

## 4. 핵심 배움 (Lessons Learned)

### 📝 메모리 안전성 (Memory Safety)
가장 큰 깨달음은 `free()` 함수의 동작 원리였습니다.

* **오개념:** `free(ptr)`를 하면 메모리가 깨끗하게 지워진다? (X)
* **사실:** 운영체제에 "이 주소 다시 써도 돼"라고 반납하는 것일 뿐, 데이터는 남아있을 수 있다. (O)
* **Action:** **Dangling Pointer** 문제를 방지하기 위해, 해제 후 반드시 `NULL` 처리를 하는 습관을 들였습니다.

```c
free(Current);
Current = NULL; // 좀비 포인터 방지


